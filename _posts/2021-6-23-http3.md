---
layout: post
title: HTTP/3 j√° √© quase um padr√£o
---

## Resum√£o para voc√™ se situar

O caminho percorrido em uma comunica√ß√£o na web passa por algumas camadas, pra ser mais preciso [quatro](https://pt.wikipedia.org/wiki/Modelo_OSI){:target="\_blank"} ou [sete](https://pt.wikipedia.org/wiki/TCP/IP){:target="\_blank"} dependendo da sua religi√£o. Independente do modelo implementado temos na primeira camada a Camada de Aplica√ß√£o que √© a mais pr√≥xima de voc√™. Ela re√∫ne protocolos como NTP para manter o seu rel√≥gio sincronizado; FTP para para fazer download e upload de arquivos; o BitTorrent que √© muito utilizado para fazer download de <del>filmes</del>‚Ä¶ distribui√ß√µes Linux; e muitos outros.

Junto dessa turminha da pesada temos o protocolo HTTP, ele √© um protocolo que foi desenvolvido originalmente para distribuir conte√∫do hipertexto ‚Äî ou seja, textos com hiperlinks que conseguem levar voc√™ a outros textos com hiperlinks.

<img src="https://whoamindx.github.io/public/posts/hypertext.png" alt="Representa√ß√£o de como funciona o linkeamento de informa√ß√µes atrav√©s do hipertexto" style="margin:0 auto; display:block">

A primeira vers√£o definitiva foi o [HTTP/0.9](https://www.w3.org/Protocols/HTTP/AsImplemented.html){:target="\_blank"} publicado em 1991, que servia apenas para transferir texto de um servidor para um computador. Em 1996 veio o [HTTP/1.0](https://www.w3.org/Protocols/HTTP/1.0/spec.html){:target="\_blank"} que contava agora com a possibilidade de incluir outros tipos de arquivos numa p√°gina, como imagens, e o novo m√©todo POST para permitir que os usu√°rios tamb√©m pudessem enviar informa√ß√µes para um servidor: criando o que conhecemos hoje como os buscadores, mensagens em redes sociais e etc.

J√° o [HTTP/1.1](https://www.w3.org/Protocols/rfc2616/rfc2616.html){:target="\_blank"} foi lan√ßado em 1999 (por coincid√™ncia, o ano em que nasci) e com ele as p√°ginas poderiam ser comprimidas no lado do servidor, e descomprimida no lado do cliente fazendo com que as p√°ginas carregassem mais r√°pido e houvesse um consumo menor no tr√°fego de rede. Essa foi a vers√£o usada por muito tempo, mais de uma d√©cada at√© a chegada do [HTTP/2](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-http2){:target="\_blank"} em 2015 que surgiu dado ao avan√ßo que a web teve: as p√°ginas ficaram muito mais pesadas contendo muito mais imagens, v√≠deos, e recursos externos como fontes, CSS e JavaScript.

Parece que foi ontem que [palestrei sobre performance de carregamento de p√°gina na comunidade WordPress Fortaleza e acabei falando do HTTP/2](https://www.instagram.com/p/BjiOIXLhDD1/){:target="\_blank"} e do recurso muito legal que vinha consigo que foi o Server Push que b√°sicamente consistia em o servidor poder enviar para o cliente j√° na primeira requisi√ß√£o alguns assets para o client. O HTTP/1.1 √© um protocolo sequencial, ou seja, ele primeiro ir√° requistar o index.html, ap√≥s o client receber o documento e come√ßar a ler, ele ir√° ver que na tag head possui um link rel stylesheet para um .css, entao o navegador ir√° solicitar o devido .css e esperar pelo retorno. Ap√≥s o .css baixado, lido e parseado o browser continua com a leitura do HTML e encontra logo em seguida um script src para um .js, ent√£o o browser ir√° requisitar o devido .js e assim voc√™ j√° deve ter entendido o problema.

A vers√£o 2 junto com Server Push veio para resolver esse tipo de problema, no momento que o client chega no servidor requisitando o index.html voc√™ poderia configurar o sevidor para que no momento de devolver o index.html ele falar: "Olha cliente, aproveita que voc√™ j√° ta aqui e leva tamb√©m esses dois arquivos css e esse javascript aqui üòÑ". Aproveitando a janela inicial de conex√£o e j√° enviando para o client em uma √∫nica ida esses dois .css e o .js, assim o cliente n√£o precise ficar indo e voltando no servidor o que faz com que tenhamos um carregamento inicial da p√°gina mais veloz.

Outra grande novidade dele foi o uso de [multiplexa√ß√£o](https://pt.wikipedia.org/wiki/Multiplexa%C3%A7%C3%A3o){:target="\_blank"}, que de forma simplificada serve para dizer que o navegador abre uma √∫nica conex√£o para baixar m√∫ltiplos arquivos, as requisi√ß√µes e respostas agora s√£o paralelas e ass√≠ncronas.

## Chegamos ent√£o no HTTP/3

L√° em meados de 2018 quando eu estava usando o HTTP/2 eu lembro de notar que na aba Network do DevTools, espec√≠ficamente do Chrome constava algo como 'HTTP/2+quic/39' e na √©poca fui atr√°s de informa√ß√µes sobre esse tal QUIC e descobri que era um protocolo criado pela google mas n√£o tinha dado muita aten√ß√£o por ser exclusivo da Google e n√£o rodar em outros browsers. Ent√£o o HTTP/3 funciona com base no QUIC e ganhou o apoio de gigantes na √©poca como Cloudflare, Google e Mozilla e isso me deixou curioso e ent√£o vim explicar para voc√™s a nova gera√ß√£o do protocolo HTTP/3.

[Anunciado em 2019](https://http3.net/){:target="\_blank"} e atualmente (estou escrevendo esse post em junho de 2021) ele j√° √© oficialmente um [Internet Draft](https://datatracker.ietf.org/doc/html/draft-ietf-quic-http-34){:target="\_blank"}, por√©m ele j√° est√° ativado por padr√£o no Chrome desde abril de 2020 na vers√£o 87 e no Firefox desde abril desse ano (2021) na sua vers√£o 88. O Edge por ser baseado no Chromium seguiu o mesmo exemplo do Chrome tamb√©m habilitando na mesma data e no mesmo n√∫nero de vers√£o. J√° o Safari havia adicionado o suporte experimental ao Safari Technology Preview em 8 de abril de 2020 e foi programado para ser lan√ßado oficialmente com o Safari 14 que vem com o macOS 11 Big Sur mas ele ainda est√° desabilitado por padr√£o.

"Bl√° bl√° bl√°... mas e o QUIC Gabriel?"<br>Ent√£o, o QUIC ele √© um protocolo da Camada de Transporte e usa o UDP o que gerou algumas pol√™micas pois a web sempre utilizou o TCP.

### Ent√£o o HTTP/3 n√£o garante a entrega do pacote?

Geralmente na faculdade (ou em algum curso que voc√™ tenha feito) nas aulas t√©oricas aprendemos que o TCP garante a entrega do pacote por√©m √© mais lento, e o UDP √© muito mais r√°pido por√©m ele n√£o garante a entrega do pacote.

<img src="https://whoamindx.github.io/public/posts/tcp-udp-meme.png" alt="Meme analogia TCP e UDP" style="margin:0 auto; display:block">

J√° reparou que quando estamos em uma chamada de voz as vezes n√£o conseguimos escutar em alguns momentos a voz da pessoa por completo e temos que falar: "Poderia repetir? Pois n√£o consegui ouvir direito, sua voz cortou no final". Esse tipo de aplica√ß√£o utiliza o UDP pois nesse caso n√£o precisamos garantir a entrega e sim a velocidade para conseguir propor a experi√™ncia de uma comuni√ß√£o em tempo real. J√° o HTTP sempre utilizou o TCP pois precisamos garantir que todos os dados sejam recebidos (a web √© lenta de nascen√ßa üòÇ).

Ent√£o √© a√≠ que entra o QUIC, ele adiciona umas camadas extra ao UDP com algumas caracter√≠sticas do TCP como retransmiss√£o de pacotes, controle de congestionamento e outras, mantendo a velocidade. Com isso, um pacote enviado atrav√©s do QUIC ser√° sempre recebido pela outra ponta, cedo ou tarde, desde que a conex√£o permane√ßa ativa. Ent√£o o QUIC usa o UDP para ter mais velocidade e junta algumas funcionalidades do TCP para que se possa ter garantia da entrega do pacote.

No TCP todos os pacotes precisam ser entregues na ordem, j√° passou pela situa√ß√£o de abrir uma p√°gina da web e de repente, o carregamento trava por alguns segundos? Uma poss√≠vel causa √© que um dos pacotes enviados pelo TCP chegou corrompido e, como o TCP precisa fornecer os dados na ordem exata, os pacotes em seguida ficam aguardando at√© que o problem√°tico seja entregue corretamente, atrasando assim toda a conex√£o.

Al√©m do mais a forma antiga de transmiss√£o de dados do HTTP, que consistia em enviar informa√ß√µes em texto puro, n√£o existe mais com o QUIC. Todas as conex√µes em HTTP/3 ser√£o feitas por meio do HTTPS e sempre criptografadas com TLS 1.3. Requisi√ß√µes para endere√ßos http:// n√£o ser√£o mais atendidas pelo novo protocolo, garantindo assim seguran√ßa.

Voc√™ pode ver no [Can I Use](https://caniuse.com/http3){:target="\_blank"} como est√° o suporte atual do HTTP/3 nos browsers.
